*** Exercise 3.21:

The implementation of queue is such that it contains two pointers to the front and rear. Thus displaying this representation
with the standard Lisp printer will not print the queue as we imagine it.

Thus inserting 'a into the empty queue generated by make-queue, means both pointers lead to the same pair and the interpreter 
will display ((a) a).

Also, deleting from the queue only moves the front pointer.  This is because the predicate for checking whether we have an empty
queue only looks at the front pointer so there is no need to alter the rear pointer when deleting from the front.

New procedure for printing the sequence of items in a queue:

(define (print-queue queue)
  (display (front-ptr queue)))


*** Exercise 3.22:

(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (set-front-ptr! item)
      (set! front-ptr item))
    (define (set-rear-ptr! item)
      (set! rear-ptr item))
    (define (empty-queue?)
      (null? front-ptr))
    (define (front-queue)
      (if (empty-queue?)
          (error "FRONT called with an empty queue" (print-queue))
          (car front-ptr)))
    (define (insert-queue! item)
      (let ((new-pair (cons item '())))
        (cond ((empty-queue?)
               (set-front-ptr! new-pair)
               (set-rear-ptr! new-pair)
               (print-queue))
              (else 
                (set-cdr! rear-ptr new-pair)
                (set-rear-ptr! new-pair)
                (print-queue)))))
    (define (delete-queue!)
      (cond ((empty-queue?)
             (error "DELETE! called with an empty queue" (print-queue)))
            (else
              (set-front-ptr! (cdr front-ptr))
              (print-queue))))
    (define (print-queue)
      (display front-ptr))
    (define (dispatch m)
      (cond ((eq? m 'empty-queue?) empty-queue?)
            ((eq? m 'front-queue) front-queue)
            ((eq? m 'insert-queue!) insert-queue!)
            ((eq? m 'delete-queue!) delete-queue!)
            ((eq? m 'print-queue) print-queue)
            (else
              (error "Undefined operation -- MAKE-QUEUE" m))))
    dispatch))

(define (empty-queue? queue) ((queue 'empty-queue?)))
(define (front-queue queue) ((queue 'front-queue)))
(define (insert-queue! queue item) ((queue 'insert-queue!) item))
(define (delete-queue! queue) ((queue 'delete-queue!)))
(define (print-queue queue) ((queue 'print-queue)))


*** Exercise 3.23:

;; Links
(define (make-link value prev next) (cons value (cons prev next)))
(define (value-link link) (car link))
(define (prev-link link) (cadr link))
(define (next-link link) (cddr link))
(define (set-value-link! link value) (set-car! link value))
(define (set-prev-link! link prev) (set-car! (cdr link) prev))
(define (set-next-link! link next) (set-cdr! (cdr link) next))

;; Deque
(define (make-deque) (cons '() '()))
(define (front-ptr deque) (car deque))
(define (rear-ptr deque) (cdr deque))
(define (set-front-ptr! deque item) (set-car! deque item))
(define (set-rear-ptr! deque item) (set-cdr! deque item))

(define (empty-deque? deque) (null? (front-ptr deque)))

(define (front-deque deque)
  (if (empty-deque? deque)
      (error "FRONT called with an empty deque" (print-deque deque))
      (value-link (front-ptr deque))))

(define (rear-deque deque)
  (if (empty-deque? deque)
      (error "REAR called with an empty deque" (print-deque deque))
      (value-link (rear-ptr deque))))

(define (front-insert-deque! deque item)
  (cond ((empty-deque? deque)
         (let ((new-link (make-link item '() '())))
           (set-front-ptr! deque new-link)
           (set-rear-ptr! deque new-link)
           (print-deque deque)))
        (else
          (let ((front-link (front-ptr deque)))
            (let ((new-link (make-link item '() front-link)))
              (set-prev-link! front-link new-link)
              (set-front-ptr! deque new-link)
              (print-deque deque))))))

(define (rear-insert-deque! deque item)
  (cond ((empty-deque? deque)
         (let ((new-link (make-link item '() '())))
           (set-front-ptr! deque new-link)
           (set-rear-ptr! deque new-link)
           (print-deque deque)))
        (else
          (let ((rear-link (rear-ptr deque)))
            (let ((new-link (make-link item rear-link '())))
              (set-next-link! rear-link new-link)
              (set-rear-ptr! deque new-link)
              (print-deque deque))))))

(define (front-delete-deque! deque)
  (cond ((empty-deque? deque)
         (error "FRONT-DELETE! called with an empty deque" (print-deque deque)))
        ((eq? (front-ptr deque) (rear-ptr deque))
         (set-front-ptr! deque '())
         (set-rear-ptr! deque '())
         (print-deque deque))
        (else
          (let ((new-front-link (next-link (front-ptr deque))))
            (set-prev-link! new-front-link '())
            (set-front-ptr! deque new-front-link)
            (print-deque deque)))))

(define (rear-delete-deque! deque)
  (cond ((empty-deque? deque)
         (error "REAR-DELETE! called with an empty deque" (print-deque deque)))
        ((eq? (front-ptr deque) (rear-ptr deque))
         (set-front-ptr! deque '())
         (set-rear-ptr! deque '())
         (print-deque deque))
        (else
          (let ((new-rear-link (prev-link (rear-ptr deque))))
            (set-next-link! new-rear-link '())
            (set-rear-ptr! deque new-rear-link)
            (print-deque deque)))))

(define (print-deque deque)
  (define (print-iter link)
    (cond ((null? link)
           (display ""))
          (else
            (display (value-link link))
            (display " ")
            (print-iter (next-link link)))))
  (print-iter (front-ptr deque)))
