*** Exercise 2.24:

(list 1 (list 2 (list 3 4)))

Interpreter:

(1 (2 (3 4)))

Box and pointer:

[.|.]-->[.|/]
 |       |
 V       V
[1]     [.|.]-->[.|/]
         |       |
         V       V
        [2]     [.|.]-->[.|/]
                 |       |
                 V       V
                [3]     [4]

Tree:

(1 (2 (3 4)))
     .
    / \ 
   /   \
  1     . (2 (3 4))
       / \
      /   \
     2     . (3 4)
          / \
         /   \
        3     4


*** Exercise 2.25:

cddadar (1 3 (5 7) 9) = 7

caar ((7)) = 7

cdadadadadadar (1 (2 (3 (4 (5 (6 7)))))) = 7


*** Exercise 2.26:

(define x (list 1 2 3))

(define y (list 4 5 6))

(append x y) => (1 2 3 4 5 6)

(cons x y) => ((1 2 3) 4 5 6)

(list x y) => ((1 2 3) (4 5 6))


*** Exercise 2.27:

(define (deep-reverse items)
  (define (iter result x)
    (cond ((null? x)
           result)
          ((not (pair? x))
           x)
          (else (iter (cons (deep-reverse (car x))
                            result)
                      (cdr x)))))
  (iter '() items))


*** Exercise 2.28:

(define (fringe tree)
  (define (iter x result)
    (cond ((null? x)
           result)
          ((pair? x)
           (iter (car x)
                 (iter (cdr x)
                       result)))
          (else
            (cons x result))))
  (iter tree '()))


*** Exercise 2.29:

a-c)

;; Constructors
(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))

;; Selectors
(define left-branch car)
(define (right-branch mobile) (car (cdr mobile)))

(define branch-length car)
(define (branch-structure branch) (car (cdr branch)))

;; Procedures
(define (total-weight mobile)
  (cond ((null? mobile)
         0)
        ((not (pair? mobile))
         mobile)
        (else (+ (total-weight (branch-structure (left-branch mobile)))
                 (total-weight (branch-structure (right-branch mobile)))))))

(define (balanced? mobile)
  (define (torque branch)
    (* (branch-length branch)
       (total-weight (branch-structure branch))))
  (cond ((pair? mobile)
         (let ((lb (left-branch mobile))
               (rb (right-branch mobile)))
           (and (equal? (torque lb)
                        (torque rb))
                (balanced? (branch-structure lb))
                (balanced? (branch-structure rb)))))
        (else #t)))

d)

Since a cons is used instead of a list, the definitions of 'right-branch' and 'branch-structure'
need to be changed to use cdr instead of cdar.  Otherwise the existing code remains intact because
it is abstracted from the implementation fo the constructors and selectors.

(define right-branch cdr)
(define branch-structure cdr)
